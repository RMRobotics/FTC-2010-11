#pragma config(Hubs,  S1, HTServo,  HTMotor,  HTMotor,  HTMotor)
#pragma config(Sensor, S2,     backLightSensor,     sensorLightActive)
#pragma config(Sensor, S3,     frontLightSensor,    sensorLightActive)
#pragma config(Sensor, S4,     distanceSensor,      sensorSONAR)
#pragma config(Motor,  motorA,          boxDoor,       tmotorNormal, PIDControl, encoder)
#pragma config(Motor,  motorB,          LeftHook,      tmotorNormal, PIDControl, encoder)
#pragma config(Motor,  motorC,          RightHook,     tmotorNormal, PIDControl, encoder)
#pragma config(Motor,  mtr_S1_C2_1,     rightWheel,    tmotorNormal, openLoop)
#pragma config(Motor,  mtr_S1_C2_2,     leftWheel,     tmotorNormal, openLoop, reversed)
#pragma config(Motor,  mtr_S1_C3_1,     rightOmniWheel, tmotorNormal, openLoop, reversed)
#pragma config(Motor,  mtr_S1_C3_2,     leftOmniWheel, tmotorNormal, openLoop)
#pragma config(Motor,  mtr_S1_C4_1,     belt,          tmotorNormal, openLoop, encoder)
#pragma config(Motor,  mtr_S1_C4_2,     scoringBox,    tmotorNormal, openLoop)
#pragma config(Servo,  srvo_S1_C1_1,    bridgeServo,          tServoStandard)
#pragma config(Servo,  srvo_S1_C1_2,    scoreBoxTilt,         tServoStandard)
#pragma config(Servo,  srvo_S1_C1_3,    dispenserDoor,        tServoStandard)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#ifndef MOTORS
#include "motorsSensors.h"
#endif
#ifndef CONST
#include "constants.h"
#endif
#ifndef HI
#include "highLevelMoves.c"
#endif

#include "JoystickDriver.c"

void processWheelMovement();
void processDispenserMovement();
void processScoringMovement();
task moveUpBridge;
bool btn6Down=false, btn12Down=false, btn5Down=false;
int scoreState=0;

task main(){

  initializeServos();

  //waitForStart(); //enable for Samantha

  do{

	  getJoystickSettings(joystick); //gathers joystick input

	  processWheelMovement();

	  processDispenserMovement();

	  processScoringMovement();

	}while(true); //This loop never ends
}

void processWheelMovement(){
  int forwardLeft, forwardRight;

  forwardLeft=(joystick.joy1_y2+joystick.joy1_x2)/2;//Two joystick drive - Max B. 2011
  forwardRight=(joystick.joy1_y2-joystick.joy1_x2)/2;
  if(abs(forwardLeft)<10)
    forwardLeft=0;
  if(abs(forwardRight)<10)
    forwardRight=0;
  if(joy1Btn(8)==1){
    forwardRight/=4;
    forwardLeft/=4;
  }

  if(joy1Btn(9)==1){ //copyrighted Hooks feature by Lev K. 2011
 	  motor[LeftHook]=35;
 	  motor[RightHook]=35;
 	}else{
    if(joy1Btn(10)==1){
      motor[LeftHook]=-50;
      motor[RightHook]=-50;
    }else{
      motor[LeftHook]=0;
      motor[RightHook]=0;
    }
  }

  if(joy1Btn(12)==1){//copyrighted PULSE feature by Max B. 2011. Do compare complexity to above script..
    if(!btn12Down){
	    switch(joystick.joy1_TopHat){
		    case 0:
		      turnOnWheels(MODE_MOVE_STRAIGHT | DIR_FWD, true);
		    break;
		    case 4://forward or backward straight
		      turnOnWheels(MODE_MOVE_STRAIGHT | DIR_BACK, true);
		    break;
		    case 2:
		      turnOnWheels(MODE_PIVOT | TURN_RIGHT, true);
		    break;
		    case 6://turning (pivot) motion
		      turnOnWheels(MODE_PIVOT | TURN_LEFT, true);
		    break;
		    case 7:
		      turnOnWheels(MODE_SWING | TURN_LEFT | DIR_FWD, true);
		    break;
		    case 1://swing forward
			    turnOnWheels(MODE_SWING | TURN_RIGHT | DIR_FWD, true);
		    break;
			  case 3:
			    turnOnWheels(MODE_SWING | TURN_RIGHT | DIR_BACK, true);
			  break;
			  case 5://swing backward
			    turnOnWheels(MODE_SWING | TURN_LEFT | DIR_BACK, true);
		    break;
		  }
		  wait10Msec(10);
		  turnOffWheels();
		  btn12Down=true;
	  }
  }else{//regular drive
    btn12Down=false;
	  switch(joystick.joy1_TopHat){
	    case 0:
	    case 4://forward or backward straight
	      turnOnWheels(MODE_MOVE_STRAIGHT | DIR_FWD, true, (forwardLeft+forwardRight)/2);
	    break;
	    case 2:
	    case 6://turning (pivot) motion
	      turnOnWheels(MODE_PIVOT | TURN_LEFT, true, forwardRight);
	    break;
	    case 7:
	    case 1://swing forward
		    turnOnWheels(MODE_SWING | TURN_LEFT | DIR_FWD, true, forwardRight-forwardLeft);
		  break;
		  case 3:
		  case 5://swing backward
		    turnOnWheels(MODE_SWING | TURN_RIGHT | DIR_BACK, true, forwardRight-forwardLeft);
	    break;
	    default://no quantization
	      setWheelPwr(forwardLeft, forwardRight, (2*forwardLeft+forwardRight)/3, (2*forwardRight+forwardLeft)/3);
	    break;
	  }
	}

	if(joy1Btn(6)==1&&!btn6Down){//lower bridge
	  btn6Down=true;
	  putDownBridge();
	  StopTask(moveUpBridge);
	  StartTask(moveUpBridge);
	}

	if(joy1Btn(6)!=1)
	  btn6Down=false;
}

void processDispenserMovement(){
  if(joy1Btn(4)==1||joy2Btn(4)==1)
    openDispenserBox();
  else
    closeDispenserBox();

  if(joy1Btn(1)==1||joy2Btn(1)==1){
    dispenseFromMiddle();
  }else{
    if(joy1Btn(2)==1||joy2Btn(2)==1){
      dispenseFromTop();
    }else{
      if(joy1Btn(3)==1||joy2Btn(3)==1){
        flipDispenserBox();
      }
    }
  }

  if(abs(joystick.joy1_y1)>10){
    if(abs(joystick.joy1_y1)<=MOTOR_SPEED)//limit to defined motor speed
      motor[belt]=-joystick.joy1_y1;//provide a manual override
  }else{
    if(abs(joystick.joy2_y1)>10){
	    if(abs(joystick.joy2_y1)<=MOTOR_SPEED)//limit to defined motor speed
	      motor[belt]=-joystick.joy2_y1;//provide a manual override
	  }else
	    motor[belt]=0;
	}

  if(joy1Btn(11)==1||joy2Btn(11)==1)
    nMotorEncoder[belt]=DISPENSER_ENC_INIT;//reset the zero starting position
}

void processScoringMovement(){
  if(scoreState==0){//in middle happy
    if(joy1Btn(5)==1||joy2Btn(5)==1){
      btn5Down=true;
      if(joy1Btn(7)==1||joy2Btn(7)==1){//confirmation for stationary dispensal
        wait10Msec(50);
        scoreOnStat();
        btn5Down=false;
      }
	  }else{
	    if(btn5Down){//just released, so put to rolling goal dispensing position
	      moveScoreBoxTo(SERVO_SCORE_BOX_TILT_ROLL);
	      scoreState=1;
	    }
	    btn5Down=false;
	  }
  }
  if(scoreState==1){//about to dispense to rolling goal
    if(joy1Btn(5)==1||joy2Btn(5)==1){//cancel
      wait10Msec(50);
      moveScoreBoxTo(SERVO_SCORE_BOX_TILT_MID);
      scoreState=0;
    }
    if(joy1Btn(7)==1||joy2Btn(7)==1){//score
      wait10Msec(50);
      openScoreBoxDoor();
      scoreState=2;
    }
  }
  if(scoreState==2){//dispensing now
    if(joy1Btn(7)==1||joy1Btn(5)==1||joy2Btn(7)==1||joy2Btn(5)==1){//close
      wait10Msec(50);
      closeScoreBoxDoor();
      scoreState=1;
    }
  }
}

task moveUpBridge(){
  wait10Msec(400);
  putDownBridge(false);
}
